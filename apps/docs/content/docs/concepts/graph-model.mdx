---
title: Graph Model
description: Understanding Mycelia's knowledge graph architecture
---

# Graph Model

Mycelia transforms your content into a queryable knowledge graph. This graph structure enables powerful navigation, discovery, and relationship mapping across your entire knowledge base.

## Graph Architecture

### Core Components

```typescript
interface MyceliaGraph {
  nodes: Record<string, MyceliaNode>;
  edges: MyceliaEdge[];
  indexes: {
    byType: Record<string, string[]>;
    byTag: Record<string, string[]>;
    byPrimitive: Record<string, string[]>;
    bySource: Record<string, string[]>;
    inbound: Record<string, string[]>;
    outbound: Record<string, string[]>;
  };
  meta: {
    generatedAt: string;
    version: string;
    files: number;
    sources: string[];
    stats: {
      nodeCount: number;
      edgeCount: number;
      typeBreakdown: Record<string, number>;
    };
  };
}
```

## Nodes

Each piece of content becomes a node in the graph:

### Node Structure

```typescript
// Base interface for all nodes
interface BaseNode {
  id: string;
  type: string;
  primitive: 'Content' | 'Reference' | 'Meta';
  created_at?: string;
  updated_at?: string;
  source: {
    file: string;
    start?: Position;
    end?: Position;
  };
}

// Content nodes (most common)
interface ContentNode extends BaseNode {
  primitive: 'Content';
  title?: string;
  content?: string;
  value?: string;
  children: string[];
  attributes: Record<string, any>;
}

// Reference nodes (links to other nodes)
interface ReferenceNode extends BaseNode {
  primitive: 'Reference';
  target: string;
  link_type: string;
  attributes: Record<string, any>;
}

// Meta nodes (tags, annotations)
interface MetaNode extends BaseNode {
  primitive: 'Meta';
  meta_type: string;
  value: string;
  target?: string;
  attributes: Record<string, any>;
}
```

### Node Primitives

Nodes are categorized by three primitive types:

| Primitive | Examples | Purpose |
|-----------|----------|---------|
| **Content** | person, project, post, task, skill | Content-bearing nodes with children |
| **Reference** | links, citations | Pointers to other nodes |
| **Meta** | tags, annotations | Metadata about content |

### Node Examples

```javascript
// Person node (Content)
{
  id: "jane-smith",
  type: "person",
  primitive: "Content",
  title: "Jane Smith",
  children: ["skill-pytorch", "skill-nlp"],
  attributes: {
    name: "Jane Smith",
    role: "Senior Engineer",
    email: "jane@example.com"
  },
  source: { file: "content/people.mdx" }
}

// Project node (Content)
{
  id: "knowledge-graph",
  type: "project",
  primitive: "Content",
  title: "Knowledge Graph Builder",
  children: ["task-1", "task-2"],
  attributes: {
    status: "in-progress",
    priority: "high"
  },
  source: { file: "content/projects.mdx" }
}

// Tag node (Meta)
{
  id: "tag-ml",
  type: "tag",
  primitive: "Meta",
  meta_type: "tag",
  value: "machine-learning",
  attributes: {},
  source: { file: "content/projects.mdx" }
}
```

## Edges

Edges represent relationships between nodes:

### Edge Structure

```typescript
interface MyceliaEdge {
  id: string;
  from: string;        // Source node ID
  to: string;          // Target node ID
  type: EdgeType;      // Relationship type
  attributes?: Record<string, any>;
}

type EdgeType = 
  | 'contains'      // Parent contains child
  | 'references'    // Node references another
  | 'mentions'      // Node mentions another
  | 'collaborates'  // Bidirectional collaboration
  | 'derives'       // Inheritance relationship
  | 'tags'          // Tag association
  | 'custom';       // User-defined type
```

### Relationship Types

#### Contains (Parent → Child)
Hierarchical relationships from nesting:

```mdx
<Project>              <!-- Parent -->
  <Task />            <!-- Child -->
</Project>

// Creates edge:
{ from: "project-id", to: "task-id", type: "contains" }
```

#### References (Node → Node)
Explicit connections between content:

```mdx
<Post>
  Written by <Person name="Jane" />
</Post>

// Creates edge:
{ from: "post-id", to: "jane", type: "references" }
```

#### Tags (Node → Tag)
Connections through tag associations:

```mdx
<Post><Tag>ml</Tag></Post>
<Project><Tag>ml</Tag></Project>

// Creates edges:
{ from: "post-id", to: "tag-ml", type: "tags" }
{ from: "project-id", to: "tag-ml", type: "tags" }
```

## Indexes

Indexes enable fast lookups and queries:

### Type Index
Groups nodes by their type:

```javascript
graph.indexes.byType = {
  'person': ['jane-smith', 'john-doe'],
  'project': ['project-alpha', 'project-beta'],
  'task': ['task-1', 'task-2', 'task-3']
}

// Query: Get all people
const people = graph.indexes.byType['person']
  .map(id => graph.nodes[id]);
```

### Tag Index
Groups nodes by tags:

```javascript
graph.indexes.byTag = {
  'machine-learning': ['post-1', 'project-ml'],
  'productivity': ['post-2', 'task-mgmt']
}

// Query: Get all ML-related content
const mlNodeIds = graph.indexes.byTag['machine-learning'];
const mlNodes = mlNodeIds.map(id => graph.nodes[id]);
```

### Primitive Index
Groups nodes by primitive type:

```javascript
graph.indexes.byPrimitive = {
  'Content': ['person-1', 'project-1', 'post-1'],
  'Meta': ['tag-1', 'tag-2'],
  'Reference': ['ref-1']
}

// Query: Get all content nodes
const contentNodes = graph.indexes.byPrimitive['Content']
  .map(id => graph.nodes[id]);
```

### Source Index
Groups nodes by source file:

```javascript
graph.indexes.bySource = {
  'content/blog.mdx': ['post-1', 'tag-1'],
  'content/projects.mdx': ['project-1', 'task-1']
}

// Query: Get all nodes from a file
const fileNodes = graph.indexes.bySource['content/blog.mdx']
  .map(id => graph.nodes[id]);
```

## Graph Operations

### Traversal

Navigate the graph to discover connections:

```typescript
// Find all tasks in a project
function getProjectTasks(graph: MyceliaGraph, projectId: string) {
  return graph.edges
    .filter(e => e.from === projectId && e.type === 'contains')
    .map(e => graph.nodes[e.to])
    .filter(n => n?.type === 'task');
}

// Find all projects that reference a person
function getPersonProjects(graph: MyceliaGraph, personId: string) {
  return graph.edges
    .filter(e => e.to === personId && e.type === 'references')
    .map(e => graph.nodes[e.from])
    .filter(n => n?.type === 'project');
}
```

### Path Finding

Find connections between nodes:

```typescript
// Find shortest path between two nodes
function findPath(graph: MyceliaGraph, startId: string, endId: string): string[] | null {
  const visited = new Set<string>();
  const queue: string[][] = [[startId]];
  
  while (queue.length > 0) {
    const path = queue.shift()!;
    const current = path[path.length - 1];
    
    if (current === endId) return path;
    if (visited.has(current)) continue;
    
    visited.add(current);
    
    // Get neighbors from edges
    const neighbors = graph.edges
      .filter(e => e.from === current || e.to === current)
      .map(e => e.from === current ? e.to : e.from);
    
    for (const neighbor of neighbors) {
      queue.push([...path, neighbor]);
    }
  }
  
  return null; // No path found
}
```

### Clustering

Identify related content clusters:

```typescript
// Find nodes related by tags
function findRelatedByTags(graph: MyceliaGraph, nodeId: string) {
  // Find all tags this node is connected to
  const nodeTags = graph.edges
    .filter(e => e.from === nodeId && e.type === 'tags')
    .map(e => e.to);
  
  const related = new Map<string, number>();
  
  // For each tag, find other nodes with the same tag
  for (const tagId of nodeTags) {
    const taggedNodes = graph.edges
      .filter(e => e.to === tagId && e.type === 'tags' && e.from !== nodeId)
      .map(e => e.from);
    
    for (const id of taggedNodes) {
      const count = related.get(id) || 0;
      related.set(id, count + 1);
    }
  }
  
  // Sort by number of shared tags
  return Array.from(related.entries())
    .sort((a, b) => b[1] - a[1])
    .map(([id]) => graph.nodes[id]);
}
```

## Query Patterns

### Type Queries

```typescript
// Get all people
const people = graph.indexes.byType['person']
  .map(id => graph.nodes[id]);

// Get all active projects  
const activeProjects = graph.indexes.byType['project']
  .map(id => graph.nodes[id])
  .filter(n => n.primitive === 'Content' && n.attributes.status === 'active');
```

### Relationship Queries

```typescript
// Get all projects that reference a person
const personProjects = graph.edges
  .filter(e => e.type === 'references' && e.to === 'jane-smith')
  .map(e => graph.nodes[e.from])
  .filter(n => n.type === 'project');

// Get project collaborators (people referenced by project)
const collaborators = graph.edges
  .filter(e => e.from === 'project-id' && e.type === 'references')
  .map(e => graph.nodes[e.to])
  .filter(n => n.type === 'person');
```

### Complex Queries

```typescript
// Find people working on ML projects
function findMLExperts(graph: MyceliaGraph) {
  // First find the ML tag node
  const mlTagId = Object.entries(graph.nodes)
    .find(([_, n]) => n.type === 'tag' && n.primitive === 'Meta' && 
          (n as MetaNode).value === 'machine-learning')?.[0];
  
  if (!mlTagId) return [];
  
  // Find all projects tagged with ML
  const mlProjects = graph.edges
    .filter(e => e.to === mlTagId && e.type === 'tags')
    .map(e => graph.nodes[e.from])
    .filter(n => n.type === 'project');
  
  // Find people referenced by those projects
  const people = new Set<string>();
  
  for (const project of mlProjects) {
    graph.edges
      .filter(e => e.from === project.id && e.type === 'references')
      .forEach(e => {
        const node = graph.nodes[e.to];
        if (node?.type === 'person') {
          people.add(node.id);
        }
      });
  }
  
  return Array.from(people).map(id => graph.nodes[id]);
}
```

## Visualization

The graph can be visualized using force-directed layouts:

```typescript
// Convert to D3-compatible format
function toD3Format(graph: MyceliaGraph) {
  return {
    nodes: Object.values(graph.nodes).map(n => ({
      id: n.id,
      group: n.primitive,
      label: n.primitive === 'Content' 
        ? (n as ContentNode).title 
        : n.type,
      type: n.type,
      ...n
    })),
    links: graph.edges.map(e => ({
      source: e.from,
      target: e.to,
      value: 1,
      type: e.type
    }))
  };
}
```

## Performance Optimization

### Lazy Loading

Load graph data on demand:

```typescript
class LazyGraph {
  private nodeCache = new Map<string, MyceliaNode>();
  
  async getNode(id: string) {
    if (!this.nodeCache.has(id)) {
      const node = await fetchNode(id);
      this.nodeCache.set(id, node);
    }
    return this.nodeCache.get(id);
  }
}
```

### Incremental Updates

Update graph without full rebuild:

```typescript
function updateNode(graph: MyceliaGraph, id: string, updates: Record<string, any>) {
  const node = graph.nodes[id];
  if (node && node.primitive === 'Content') {
    Object.assign((node as ContentNode).attributes, updates);
    node.updated_at = new Date().toISOString();
    // Re-index the node
    updateIndexes(graph, node);
  }
}
```

### Caching Strategies

Cache common queries:

```typescript
const queryCache = new Map<string, any>();

function cachedQuery<T>(key: string, query: () => T): T {
  if (!queryCache.has(key)) {
    queryCache.set(key, query());
  }
  return queryCache.get(key)!;
}

// Usage
const people = cachedQuery('all-people', 
  () => graph.indexes.byType['person'].map(id => graph.nodes[id])
);
```

## Best Practices

1. **Keep nodes focused**: One concept per node
2. **Use consistent IDs**: Predictable ID generation
3. **Index strategically**: Only index queryable fields
4. **Minimize edge types**: Use standard relationships
5. **Cache aggressively**: Graph queries can be expensive

## Next Steps

- Learn about [Parser](/docs/parser/overview) internals
- Explore [Graph Visualization](/docs/components/graph)
- Optimize [Performance](/docs/advanced/performance)
- Build [Custom Queries](/docs/api/core)